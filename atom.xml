<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lilac&#39;s Blog</title>
  
  <subtitle>Struggle</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilac18.cn/"/>
  <updated>2020-10-23T08:00:28.528Z</updated>
  <id>https://lilac18.cn/</id>
  
  <author>
    <name>Lilac</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Prism阅读笔记</title>
    <link href="https://lilac18.cn/2020/10/23/Prism%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://lilac18.cn/2020/10/23/Prism%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-23T07:28:47.000Z</published>
    <updated>2020-10-23T08:00:28.528Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文题目：Prism: Deconstructing the blockchain to approach physical limits</strong></p><p><strong>论文来源：CCS2019</strong></p><p><strong>主要目的：</strong>比特币性能距离物理限制很远。</p><p>衡量比特性能的指标：</p><ul><li>β恶意算力比例</li><li>λ交易吞吐量：每秒可确认的交易数量，比特币为7TPS</li><li>τ：交易的确认等待延迟，比特币为6个区块的时间</li></ul><p>物理限制指标：</p><p>C：物理带宽，每秒可以承载的数据量，本文用每秒可以承载的交易数量来衡量</p><p>D：光速的传播延迟</p><p><font color="red">CD指标表示“在空中”的数据量，本文可以理解为在传播中的交易</font></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023154143-866694.png" alt="image-20201023154142008"></p><p><strong>论文贡献：</strong></p><p>本文提出了一个新的PoW协议，Prism，它实现了以下几点：</p><p>（1）具有可以抵御少于50%恶意算力的安全性；</p><p>（2）具有可以接近网络容量C上限的吞吐量；</p><p>（3）当确认错误概率ε是指数级小于带宽时延迟CD时，诚实交易的确认等待时间和光速传播延迟D成比例的。</p><p>（4）最终有完整交易确认顺序。</p><p><strong>论文idea出发点：</strong></p><p>当前区块链的问题：</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023154331-436592.png" alt="image-20201023154330044"></p><p>不受限制提高挖矿速率和区块大小的问题：</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023154449-13980.png" alt="image-20201023154447168"></p><p>本文的idea:功能解构比特币，根据确认等待时间和吞吐量，进行扩容设计，达到物理限制</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023154646-613748.png" alt="image-20201023154644884"></p><p><strong>论文方案：</strong></p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201023154730889.png" alt="image-20201023154730889"></p><p>可以进一步扩展</p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201023154745128.png" alt="image-20201023154745128"></p><p><strong><font color="green">详细实现</font></strong></p><p>数据结构</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023154848-174702.png" alt="image-20201023154848162"></p><p>具体的POW过程：</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023155026-238373.png" alt="image-20201023154910041"></p><p>需要注意的点：</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023155118-729862.png" alt="image-20201023155113233"></p><p>交易列表设计：</p><p>列表确认，同层多个提交区块可以暂时放到列表里都确认，而不需要马上获取leader。这个设计可以做到交易确认可以早于账本确定。transaction confirmed earlier than transaction ordered.</p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201023155331324.png" alt="image-20201023155331324"></p><p><strong>分析与总结：</strong></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023155440-934250.png" alt="image-20201023155440077"></p><p>保守来看，Prism的每个投票树都是和比特币一样的最长连原则，出现分叉需要k-deep规则，但是基于其快速的交易确认机制以及多条投票链整合的作用，实际投票确认还是很快的。</p><p>针对提交区块的情况直观分析有两种。</p><p><font color="blue">情况1：</font>交易区块TB由一个孤立的提交区块指向。同一层只有一个公开的提交区块。这是很常见的，如果投票树较多时。</p><p>攻击者挖一个私有的提交区块A，在每个投票树的进行分叉，在分叉链上挖矿，给A投票。就算H被选为leader，攻击者还可以继续在分叉的投票树上挖矿，给A投票，企图改写，如果票数超过H，理论上是可以成功的。</p><p>*<font color="red">注意：上代链接是PoW之后填充的。</font>*</p><p>情况1的解决办法：</p><p>在2-deep等待1000张投票。这个时间远低于单一链等待24个区块的时间。</p><p><font color="blue">情况2：</font>交易区块TB由H1指向，H1不是孤立提交块。由一个恶意的公有提交块A1竞争，竞争者A1也可以是诚实的。A是恶意的私有提交区块。这个竞争可以持续L层，直到一个孤立的诚实提交区块出现。图中L=1。</p><p>根据TB是诚实交易还是双花交易讨论。</p><p>诚实交易：</p><p>最直接的办法就是一直等待知道可以确认H1或者A1。但是是很慢的，因为攻击者试图去平衡票数。</p><p>解决办法：不是单一确认，而是列表确认。就算A1被确认，诚实的H2可以引用TB。</p><p>快速的列表确认可以防止攻击者试图产生多于H1或者A1票数的私有区块A。</p><p>双花交易：</p><p>解决办法：单一的区块确认，一出现列表确认就确认谁是最后的leader。</p><p><strong>理论结果：</strong></p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201023155849097.png" alt="image-20201023155849097"></p><p><strong>实验结构：</strong></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20201023155932-673451.png" alt="image-20201023155930714"></p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201023155952311.png" alt="image-20201023155952311"></p><p><strong>个人总结：</strong></p><p>​    Prism依据区块不同功能对比特币协议进行了解构，将区块划分为三种类型，针对吞吐量和交易确认时间进行“结构化DAG”扩展设计，证明了对区块链进行功能解构是可以做到物理资源充分利用的。</p><p>个人总结：</p><p>​    本文和我们所进行的工作的相关的，涉及到了多链结构和分离设计。</p><p>​    区别在于Prism调节难度阈值对区块分类，而我们调节难度值不影响记账权力，Prism的分离结构设计更准确说是分类，我们的分离设计更准确说是拆分。</p><p>   Prism的整体设计很大胆，可以和我们的想法对比思考。Prism的性能证明是理论化的，该团队的同源文章可能有实际的数据基础。</p>]]></content>
    
    <summary type="html">
    
      分离区块链的三种角色进行功能解构
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://lilac18.cn/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>FruitChains阅读整理</title>
    <link href="https://lilac18.cn/2020/10/23/FruitChains%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86-1/"/>
    <id>https://lilac18.cn/2020/10/23/FruitChains%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86-1/</id>
    <published>2020-10-23T07:23:51.000Z</published>
    <updated>2020-10-23T07:28:09.434Z</updated>
    
    <content type="html"><![CDATA[<p>*<em>论文题目：FruitChains: A Fair Blockchain  *</em></p><p><strong>论文来源：PODC2017（CCF-B）</strong></p><p>主要目的：为了使得区块链的奖励更加公平。拥有多少算力的矿工可以得到多少奖励。</p><p>问题来源：由于矿池的存在，自私挖矿等风险，但对的矿工能够获取的奖励实际上并不能达到自己算力所占份额的。作者认为这是因为当前奖励机制单一化造成的，将矿工能得到的奖励分为挖矿奖励和交易费用两个部分，对这两个部分的处理过程进行单独分离可以缓解上述问题。做到所谓的奖励公平。</p><p>主体思想：</p><p>区块链中存在两种形式的区块。区块和水果。他们本质上的数据结构是相似的。根据不同的挖矿难度或者不同的标记，矿工可以得到这两种东西。</p><p>初始有一个创世区块，矿工基于它挖出水果。或者区块，区块是包含水果的。水果包含交易。水果是“悬挂”到某个区块上的。包含水果的区块距离悬挂水果的区块不能太远。</p><p>总结：思想和GHOST有相似，但是GHOST是引用和奖励。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;*&lt;em&gt;论文题目：FruitChains: A Fair Blockchain  *&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;论文来源：PODC2017（CCF-B）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要目的：为了使得区块链的奖励更加公平。拥有多少算力的矿工可以得到多少奖
      
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://lilac18.cn/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>123</title>
    <link href="https://lilac18.cn/2020/09/12/123/"/>
    <id>https://lilac18.cn/2020/09/12/123/</id>
    <published>2020-09-12T10:53:43.000Z</published>
    <updated>2020-09-12T10:53:43.991Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>OHIE阅读笔记</title>
    <link href="https://lilac18.cn/2020/09/12/OHIE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://lilac18.cn/2020/09/12/OHIE%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-12T05:43:53.000Z</published>
    <updated>2020-09-12T07:05:51.077Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文来源：</strong></p><p>S&amp;P 2020  Haifeng Yu  </p><p><strong>概述：</strong></p><p>OHIE 介绍了一种并行的区块链结构和新的区块确认机制。理论性证明了安全性和效率提高。设计思路对于我的算力重利用Idea有较大启发，合理利用可以做到正真意义上的算力利用。</p><p><strong>设计细节：</strong></p><p>在比特币里，B区块从已经存在的A区块扩展。B区块包含A区块的哈希值。因此建立连接。</p><p>在OHIE里，矿工挖矿之前不知道新的快要连接到哪条链上。最后的k位决定了新块的位置，即新块属于哪一条链。</p><p>为了解决这个问题，OHIE中矿工链接每条链的最后一个块进行merkle根计算。利用merkle根的值进行PoW的输入数据。得到的值更具最后的k位代表新块的位置。此处采取的merkle证明是标准的merkle证明。</p><p>挖矿的过程站在多个矿工的角度看待问题，一个时隙同时产生2^K个块儿都可以加入体系。</p><p>确认环节：（SCB确认区块序列）</p><p><img src="/.cn//C:%5CUsers%5Clilac%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200912144601166.png" alt="image-20200912144601166"></p><p>T表示不稳定参数。T=2表示最后两个块默认是不稳定的。</p><p>每一个出块的时间间隔都是是稳定快可当作确认块。确认块的个数是结构纵向的一个数为了保证部分确认块最小。不稳定块出外所有的块都是部分确认块。</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200912145003-693225.png" alt="image-20200912145001967"></p><p>在上述部分确认-完全确认块的基础上引入成对标记（rank,next_rank），所有块儿都需要这个标记，包括不是部分确认的块儿。</p><p>初始的每条链的第一个块都是（0，1）,具体确认过程如图。</p>]]></content>
    
    <summary type="html">
    
      OHIE提出一种并行的多条链结构
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://lilac18.cn/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>idea 雏形</title>
    <link href="https://lilac18.cn/2020/09/09/idea-%E9%9B%8F%E5%BD%A2/"/>
    <id>https://lilac18.cn/2020/09/09/idea-%E9%9B%8F%E5%BD%A2/</id>
    <published>2020-09-09T06:20:00.000Z</published>
    <updated>2020-09-09T06:21:15.594Z</updated>
    
    <summary type="html">
    
      idea最开始大概的想法
    
    </summary>
    
    
      <category term="idea" scheme="https://lilac18.cn/categories/idea/"/>
    
    
  </entry>
  
  <entry>
    <title>Bitcoin-NG阅读笔记</title>
    <link href="https://lilac18.cn/2020/09/08/Bitcoin-NG%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://lilac18.cn/2020/09/08/Bitcoin-NG%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-08T00:43:57.000Z</published>
    <updated>2020-09-08T03:23:57.919Z</updated>
    
    <content type="html"><![CDATA[<p><strong>论文来源：</strong></p><p>​       NSDI（2016） Ittay Eyal      </p><p><strong>概述：</strong></p><p>​        Bitcoin-NG，一个基于比特币信任模型的可扩展的区块链协议。Bitcoin-NG通过将比特币的区块链操作分解为两部分来实现这个性能改善：首领选择（<code>leader election</code>）和交易序列化（<code>transaction serialization</code>）。它将时间划分为新片段，每一个片段都有单独的首领。在比特币中，首领选择是随意执行的，且不经常发生。一旦选择好首领，它就有资格序列化交易，直到一个新的首领出现，标记在前一个片段的尾部。  </p><p>​        比特币中也有首领选择。但是在比特币中，首领负责序列化历史记录，使得首领选择之间的持续时间成为了长时间的系统冻结。相反，Bitcoin-NG中的首领选择是向前进行的，确保系统能够持续处理交易。    </p><p><strong>关键技术思想：</strong></p><p><strong>A.详细的协议运算</strong></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200908093134-536046.png" alt="image-20200908093134218"></p><p>Bitcoin-NG链的结构。微区块（圆圈）是用私钥来签名的，该私钥与最后关键区块（正方形）的公钥相匹配。40%的交易费分发给首领，60%分发给下一个区块。</p><p>​        在Bitcoin-NG中，区块被分成了两种，分别是核心块（key block）和微块（microblock）。矿工们对区块的操作也被分成了两个阶段，分别是选举领导者和打包交易。Bitcoin-NG把时间分成了多个时代（epoch），每一个时代选举出一个领导（leader）。选举领导的过程同比特币的挖矿过程相同，每一个矿工在前一个领导生产的微块的基础上进行挖矿。一旦某个矿工被选定成为领导，他需要把可以验证自己领导身份的信息放到核心块（key block）中，并把它连接到链上。然后这个矿工就可以以预先设定好的速度持续生产微块（microblock），直到下一个矿工在自己生产的微块基础上挖矿成功并成为新的领导者，这也意味着当前领导者的领导时代结束。</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200908093443-92546.png" alt="image-20200908093443197"></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200908093823-584628.png" alt="image-20200908093823127"></p><p>当有分叉时，在所有关键区块中，由最多算力生成的那条区块链才是主链，这样就打破了僵局。</p><p>目前的首领获得40%的交易费，紧接着的首领获得60%的交易费。事实上，补偿是这样实施的，即每一个关键区块包含一个独立的交易数据库，该数据库用来铸造新币和将资金分发给现有首领和上一个首领。</p><span class="label primary">由于微区块不需要挖矿，首领将不同的重复状态机的状态公布给不同的机器，会造成双花攻击，不同的节点认为同样的币由不同的交易花费</span>  <span class="label primary">本文使用了专门的账本来作废欺骗者的收益，即污染交易，包含了修剪分支的第一个区块的数据作为欺骗证据。污染交易必须在首领花费这些收益之前放置在下一个关键区块后面。污染交易还会给现在的首领分发部分补偿如5%</span><p><strong>B.安全分析</strong></p><p>激励机制</p>]]></content>
    
    <summary type="html">
    
      Bitcoin-NG 实现了目标值计算和交易相分离的概念设
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://lilac18.cn/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>广度优先走迷宫以及http等基本库了解</title>
    <link href="https://lilac18.cn/2020/08/16/go%E8%B5%B0%E8%BF%B7%E5%AE%AB%E4%BB%A5%E5%8F%8Ahttp%E5%BA%93%E4%BA%86%E8%A7%A3/"/>
    <id>https://lilac18.cn/2020/08/16/go%E8%B5%B0%E8%BF%B7%E5%AE%AB%E4%BB%A5%E5%8F%8Ahttp%E5%BA%93%E4%BA%86%E8%A7%A3/</id>
    <published>2020-08-16T01:08:04.000Z</published>
    <updated>2020-08-16T02:56:42.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广度优先算法走迷宫"><a href="#广度优先算法走迷宫" class="headerlink" title="广度优先算法走迷宫"></a>广度优先算法走迷宫</h3><p>思路：节点分为三个状态：未发现，发现未探索，已探索</p><p>设定一个steps数组对应maze数组，设立每个点的坐标结构体，利用一个队列存放发现未探索的点。</p><p>迷宫文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>走迷宫代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readMaze</span><span class="params">(filename <span class="keyword">string</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">file, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> row, col <span class="keyword">int</span></span><br><span class="line">fmt.Fscanf(file, <span class="string">"%d %d"</span>, &amp;row, &amp;col)</span><br><span class="line">maze := <span class="built_in">make</span>([][]<span class="keyword">int</span>, row)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> maze &#123;</span><br><span class="line">maze[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, col)</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> maze[i] &#123;</span><br><span class="line">fmt.Fscanf(file, <span class="string">"%d"</span>, &amp;maze[i][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maze</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">i, j <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dirs = [<span class="number">4</span>]point&#123;</span><br><span class="line">&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, <span class="comment">//上左下右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p point)</span> <span class="title">add</span><span class="params">(r point)</span> <span class="title">point</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> point&#123;p.i + r.i, p.j + r.j&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p point)</span> <span class="title">at</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.i &lt; <span class="number">0</span> || p.i &gt;= <span class="built_in">len</span>(grid) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.j &lt; <span class="number">0</span> || p.j &gt;= <span class="built_in">len</span>(grid[p.i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> grid[p.i][p.j], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">(maze [][]<span class="keyword">int</span>, start, end point)</span> <span class="params">([][]<span class="keyword">int</span>, point)</span></span> &#123;</span><br><span class="line">steps := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(maze))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> steps &#123;</span><br><span class="line">steps[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(maze[i]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q := []point&#123;start&#125;</span><br><span class="line">realEnd := point&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(Q) &gt; <span class="number">0</span> &#123;</span><br><span class="line">cur := Q[<span class="number">0</span>]</span><br><span class="line">Q = Q[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">realEnd = cur</span><br><span class="line"><span class="keyword">if</span> cur == end &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">next := cur.add(dir)</span><br><span class="line"></span><br><span class="line"><span class="comment">//maze at next is 0</span></span><br><span class="line"><span class="comment">//and steps at next is 0</span></span><br><span class="line"><span class="comment">//and next != start</span></span><br><span class="line">val, ok := next.at(maze)</span><br><span class="line"><span class="keyword">if</span> !ok || val == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val, ok = next.at(steps)</span><br><span class="line"><span class="keyword">if</span> !ok || val != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next == start &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curSteps, _ := cur.at(steps)</span><br><span class="line">steps[next.i][next.j] = curSteps + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Q = <span class="built_in">append</span>(Q, next)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> steps, realEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWay</span><span class="params">(steps [][]<span class="keyword">int</span>, start point, end point)</span> []<span class="title">point</span></span> &#123;</span><br><span class="line">way := []point&#123;end&#125;</span><br><span class="line"><span class="keyword">for</span> cur := end; cur != start; &#123;</span><br><span class="line">curSteps, _ := cur.at(steps)</span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">next := cur.add(dir)</span><br><span class="line">nextSteps, _ := next.at(steps)</span><br><span class="line"><span class="keyword">if</span> nextSteps == curSteps<span class="number">-1</span> &#123;</span><br><span class="line">cur = next</span><br><span class="line">way = <span class="built_in">append</span>(way, next)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> way</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">maze := readMaze(<span class="string">"maze/maze.in"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印检查读取maze对不对</span></span><br><span class="line">fmt.Println(<span class="string">"迷宫形状："</span>)</span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> maze &#123;</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> row &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%3d"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">start, end := point&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, point&#123;<span class="built_in">len</span>(maze) - <span class="number">1</span>, <span class="built_in">len</span>(maze[<span class="number">0</span>]) - <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">steps, realEnd := walk(maze, start, end)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"路径图："</span>)</span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> steps &#123;</span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> row &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%3d"</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endSteps, _ := realEnd.at(steps)</span><br><span class="line">fmt.Println(<span class="string">"走过步长："</span>, endSteps)</span><br><span class="line"></span><br><span class="line">way := getWay(steps, start, realEnd)</span><br><span class="line"><span class="keyword">var</span> forwardWay []point</span><br><span class="line">fmt.Printf(<span class="string">"路径为:"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(way) - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i-- &#123;</span><br><span class="line">forwardWay = <span class="built_in">append</span>(forwardWay, way[i])</span><br><span class="line">fmt.Print(<span class="string">" "</span>, way[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> realEnd.i == end.i &amp;&amp; realEnd.j == end.j &#123;</span><br><span class="line">fmt.Println(<span class="string">"到达终点"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"没有路径"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些基本库"><a href="#一些基本库" class="headerlink" title="一些基本库"></a>一些基本库</h3><ul><li>http</li><li>bufio</li><li>encoding/json</li><li>time</li><li>log</li><li>regexp</li><li>strings/math/rand</li></ul><p>看标准库文档需要本地起一个服务器 godoc -http :8888或者使用<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">网址</a></p><h4 id="gin框架—第三方http框架"><a href="#gin框架—第三方http框架" class="headerlink" title="gin框架—第三方http框架"></a>gin框架—第三方http框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com&#x2F;gin-gonic&#x2F;gin</span><br></pre></td></tr></table></figure><p>利用gin和zap的样例，设计middleware</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyRequestID = <span class="string">"requestID"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">logger, err := zap.NewProduction()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">s := time.Now()</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录路径,返回码,耗时</span></span><br><span class="line">logger.Info(<span class="string">"incoming request"</span>,</span><br><span class="line">zap.String(<span class="string">"path"</span>, c.Request.URL.Path),</span><br><span class="line">zap.Int(<span class="string">"status"</span>, c.Writer.Status()),</span><br><span class="line">zap.Duration(<span class="string">"elapsed"</span>, time.Now().Sub(s)),</span><br><span class="line">)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Set(keyRequestID, rand.Int())</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">h := gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>:    <span class="string">"pong"</span>,</span><br><span class="line">keyRequestID: <span class="number">1234</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rid, exists := c.Get(keyRequestID); exists &#123;</span><br><span class="line">h[keyRequestID] = rid</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(<span class="number">200</span>, h)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(<span class="number">200</span>, <span class="string">"hello"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows "localhost:8080")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      爬虫项目准备
    
    </summary>
    
    
      <category term="go" scheme="https://lilac18.cn/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go自身特色归纳</title>
    <link href="https://lilac18.cn/2020/08/13/go%E8%87%AA%E8%BA%AB%E7%89%B9%E8%89%B2%E5%BD%92%E7%BA%B3/"/>
    <id>https://lilac18.cn/2020/08/13/go%E8%87%AA%E8%BA%AB%E7%89%B9%E8%89%B2%E5%BD%92%E7%BA%B3/</id>
    <published>2020-08-13T00:04:33.000Z</published>
    <updated>2020-08-16T01:15:03.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="part2-go高级用法特色总结"><a href="#part2-go高级用法特色总结" class="headerlink" title="part2 go高级用法特色总结"></a>part2 go高级用法特色总结</h2><h4 id="1-面向接口"><a href="#1-面向接口" class="headerlink" title="1 面向接口"></a>1 面向接口</h4><p>接口的目的。相当于为了解耦合。不同模块实现一个目的可能不同，在总的调用时只关心实现了函数没有，不关心函数内部是什么。即，go语言接口关心的是是否实现接口函数而不是实现接口。实现接口函数相当于实现接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRetriver</span><span class="params">()</span> <span class="title">retriever</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testing.Retriver&#123;&#125;  <span class="comment">//真正实用的retriver</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?:Something that can "Get"</span></span><br><span class="line"><span class="keyword">type</span> retriver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r retriver = getRetriver()</span><br><span class="line">    fmt.Println(r.Get(<span class="string">"https://www.baidu.com"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>duck typing:</strong></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200813094440-737531.png" alt="image-20200813094439318"></p><p>大黄鸭是不是鸭子？</p><p>对于传统定义来说大黄鸭不是鸭子，因为没有生命。</p><p>但是对于duck typing角度来说就是鸭子：像鸭子，有鸭子的特征。</p><p><font color="red">duck typing描述事物的外部行为而不是内部结构</font></p><p>python的接口需要注释声明实现者需要实现接口的什么函数。java不需要注释，java直接要求实现整个接口。也就是说java的接口实际上不属于duck typing，并且java没法组合使用接口。go语言综合了上述有点，不需要实现接口也不需要注释，但是还可以保证接口实现检查，其次可以实现接口的组合使用。</p><p>（1）实现者和使用者。和传统语言不同的是，go的接口是使用者来定义的，实现者只需隐式地实现接口，即实现者实现使用者规定的方法就等于实现了接口。</p><p>（2）接口变量的组成。是由实现者的类型和实现者的指针组成。几乎不使用接口的指针，因为接口变量自带指针。指针接收者实现只能以指针的方式使用，值接收者都可以。</p><p>（3）任意类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>任意类型的类型判断是.(type)，即type assertion 。</p><p>（4）接口的组合。接口的组合也是使用者来定义的。实现者只需实现方法，不需要关注使用者到底是什么接口。</p><p><strong>常用系统接口：</strong></p><ul><li>stringer，需要实现String()</li><li>reader，需要实现Read()</li><li>writer，需要实现Write()</li></ul><p>reader 和 writer 不仅可以用于文件读写，也可以用于网络的读写，或者[]byte,string等等都可以用。</p><h4 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2 函数式编程"></a>2 函数式编程</h4><p>函数是一等公民，参数、变量、返回值都可以是函数。</p><p><strong>闭包：</strong></p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200813113644-722293.png" alt="image-20200813113643403"></p><p>闭包针对的是作为返回值的函数而言。自由变量指的是不在闭包函数内部的变量。也就是主调函数的变量或者外部传入的变量。闭包函数返回时返回的是一个闭包，及闭包函数本身以及它的局部变量的值以及自由变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := adder()</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"0+1+...+%d=%d"</span>,i,a(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解：可以理解为此处闭包的目的是为了每次将sum存起来，也就是将函数adder()赋值给a作为一个变量的目的。相当于这个状态是保存在a里的。所以每次调用a(i)的话实际上a的sum是上次结束更改后的值。而adder()函数的目的是计算上的处理，实际的值由a决定。</p><p>闭包的使用依赖于设定一个变量接收函数作为生成器。</p><p>函数作为一等公民可以实现接口，也可以作为参数传递。</p><h4 id="3-资源管理和错误处理"><a href="#3-资源管理和错误处理" class="headerlink" title="3 资源管理和错误处理"></a>3 资源管理和错误处理</h4><p><strong>资源管理：</strong>defer 在函数退出时执行，进行资源管理。defer内部有一个栈是先进后出的，不过不太需要关注这个点。defer使用场景：open/close,lock/unlock,printheader/printfooter。</p><p><strong>错误处理：</strong>实际上就是尽力避免panic。把已知的err处理了，然后return。未知的error使用panic。</p><p><font color="red"> panic: </font>停止当前函数执行。一直向上返回，执行每一层defer。没有遇到recover程序退出。</p><p><font color="blue"> recover: </font>仅在defer调用中使用，获取panic的值，如果无法处理可重新panic。</p><h4 id="4-测试和性能调优-了解"><a href="#4-测试和性能调优-了解" class="headerlink" title="4 测试和性能调优 //了解"></a>4 测试和性能调优 //了解</h4><p><strong>表格驱动测试：</strong>go写表格驱动测试很方便。文件命名以_test.go结束。测试函数名以Test开头，参数为t *testing.T类型，出错调用t.Errorf()显示打印。</p><p>此外，测试还可以利用命令行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test .</span><br></pre></td></tr></table></figure><p><strong>代码覆盖率：</strong>IDE操作或者命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go test -coverprofile&#x3D;c.out</span><br><span class="line">go tool cover -html&#x3D;c.out</span><br></pre></td></tr></table></figure><p><strong>性能测试：</strong>测试函数以Benchmark开头，参数为b *testing.B。选取较复杂的测试样例。出错调用b.Errof()显示打印。较复杂的样例做很多遍，遍数不是人规定，由b.N决定。也可以使用命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench .</span><br></pre></td></tr></table></figure><p><strong>性能调优：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go test -bench . -cpuprofile cpu.out</span><br><span class="line">go tool pprof cpu.out</span><br><span class="line">&gt;&gt;web</span><br><span class="line">&#x2F;&#x2F;需要安装graphviz再使用web</span><br></pre></td></tr></table></figure><p>性能图里方框越大、线条越粗表示花费时间越多的地方，可以进行代码优化。</p><p><strong>生成文档和示例代码：</strong></p><p>文档内容就是注释解释的函数的功能</p><p>下载godoc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;godoc</span><br></pre></td></tr></table></figure><p>利用工具godoc：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http :6060</span><br></pre></td></tr></table></figure><p>go 文件内部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数功能描述                 ---&gt;文档</span></span><br><span class="line"><span class="comment">//    eg.                     ---&gt;带框文档</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><p>在test文件内,是一种特殊的test，之后可以godoc查看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example</span>包名_函数名（）</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Output:</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-Goroutine"><a href="#5-Goroutine" class="headerlink" title="5 Goroutine"></a>5 Goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i]++</span><br><span class="line"><span class="comment">//runtime.Gosched()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这里goroutine内部写和main打印有一定的数据冲突。需要通过channel解决。goroutine是轻量级的线程—协程，非抢占式多任务处理。</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200814113426-312210.png" alt="image-20200814113425381"></p><p>普通函数：子函数从main函数数获得控制权执行结束返回控制权和数据。</p><p>协程：子函数和main由两个协程进行，控制权和数据在执行过程不断交替，有一个通道。</p><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200814113911-682794.png" alt="image-20200814113909896"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用go run -race file.go 进行数据冲突检测</span><br></pre></td></tr></table></figure><p>goroutine可能切换点：只是参考，不能保证参考，也不能保证其他地方不切换</p><p>(1)I/O，select (2)channel (3)等待锁 (4)函数调用（有时） (5)runtime.Gosched() </p><h4 id="6-Channel"><a href="#6-Channel" class="headerlink" title="6 Channel"></a>6 Channel</h4><p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200815115033-583286.png" alt="image-20200815115032401"></p><p>Channel是两个goroutine之间的通道。channel的箭头代表了channel的类型，指向channel表示channel是send类型，该channel只能发数据；由channel指出去表示channel是receive类型，该channel只能收数据。</p><p><strong>bufferedChannel:</strong>建立channel的时候设立缓冲区，可以提升性能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>channel可以用range来收进行关闭。</p><span class="label success">“不要通过共享内存来通信，通过通信来共享内存”</span><p><strong>使用channel等待任务结束：</strong></p><p>借助库sync.WaitGroup。利用wg.Add(),wg.Done(),wg.Wait()三个函数</p><p>单任务结束直接close通道即可。</p><p><strong>使用select进行调度：</strong></p><p>两个channel，谁先来想收谁的数据，利用select</p><p>定时器的使用。在select中使用nil channel</p><p><strong>传统同步机制了解：</strong>WaitGroup,Mutex,Cond。传统机制用的很少，基本都是用channel。</p>]]></content>
    
    <summary type="html">
    
      语言特色
    
    </summary>
    
    
      <category term="go" scheme="https://lilac18.cn/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>go基本语法注意点归纳</title>
    <link href="https://lilac18.cn/2020/08/12/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9%E5%BD%92%E7%BA%B3/"/>
    <id>https://lilac18.cn/2020/08/12/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9%E5%BD%92%E7%BA%B3/</id>
    <published>2020-08-12T02:35:41.000Z</published>
    <updated>2020-08-16T01:15:22.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="part1-基本语法注意点"><a href="#part1-基本语法注意点" class="headerlink" title="part1 基本语法注意点"></a>part1 基本语法注意点</h3><p><strong>内建变量类型：</strong></p><p>bool,string,</p><p>(u)int,(int8,int16,int32,int64,intptr)</p><p>byte(8位，相当于int8别名),rune(32位也就是char,相当于int32别名)</p><p>float32,float64,complex64(32位复数),complex128</p><p><strong>内建容器类型：</strong></p><p>array,slice,map</p><h4 id="（1）分支"><a href="#（1）分支" class="headerlink" title="（1）分支"></a>（1）分支</h4><p>switch语句，switch后可以不写变量名如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a &lt; <span class="number">10</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> a &lt; <span class="number">5</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for可以省略起始条件、结束条件、循环条件</p><h4 id="2-指针"><a href="#2-指针" class="headerlink" title="(2)指针"></a>(2)指针</h4><p>go语言只有值传递一种方式。go语言的指针不能运算。go语言的结构体实际上是指针指向数据块的结构，也就是结构体函数传递了一个指针，如果要维护原有结构体的话需要传递一个指针，通过封装避免错误。</p><h4 id="3-数组、切片、map"><a href="#3-数组、切片、map" class="headerlink" title="(3)数组、切片、map"></a>(3)数组、切片、map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> arr = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;<span class="comment">//切片</span></span><br></pre></td></tr></table></figure><ul><li>数组是值类型。想更改需要使用指针。一般不使用数组，常见使用切片slice。</li><li>slice是对数组的一个view。slice可以多次reslice。slice是可以向后扩展的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">1</span>:<span class="number">4</span>]<span class="comment">//[2,3,4]</span></span><br><span class="line">s2 := s1[<span class="number">2</span>:<span class="number">4</span>]<span class="comment">//[4,5]</span></span><br></pre></td></tr></table></figure><p>slice底层实现实际上由ptr,len,cap组成。s1下标取是不能超过2的。但是向后扩张s2只要不超过cap就好了。s1的cap是4，s2的cap是2。</p><p>slice如果append超出slice,会分配新的空间。所以需要接收新的slice。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">append</span>(s,<span class="built_in">new</span>)</span><br></pre></td></tr></table></figure><p>常用内建函数：make,copy(dst,src)</p><ul><li>map如果某个键不存在可以通过接收两个值判断。map内部是无序的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value,ok := m[<span class="string">"not exist key"</span>] <span class="comment">// 返回空串和false</span></span><br></pre></td></tr></table></figure><p>常用内建函数：delete(map,key)</p><p>几乎所有内建类型都可以作为key。除了没法判断相等的slice,map,function。自建类型struct不包含上述三个也可以作为key。</p><ul><li>字符字符串的操作：rune的使用。strings包。<h4 id="4-面向“对象”"><a href="#4-面向“对象”" class="headerlink" title="(4)面向“对象”"></a>(4)面向“对象”</h4></li></ul><p>go只支持封装，没有继承和多态，只有struct。</p><ul><li><p>结构体没有构造函数，利用自定义工厂函数和接口来操作结构体。go可以返回局部变量的指针来用。go有垃圾回收机制不需要关注局部变量的分配位置在堆上还是栈上。</p></li><li><p>结构定义方法使用接收者。实际上和普通函数很类似，接收者可看作参数。</p></li><li><p>想要更改结构体的内部，可以将接收者设为指针类型。但是调用的时候不需要区分，编译器会根据接收者类型自行处理。</p></li></ul><p><strong>使用技巧：</strong>要改变内容用指针接收这；结构过大使用指针接收者；（最好）有指针接收者都是指针接收者</p><ul><li><p>扩展已有类型的方法有组合、别名和内嵌。组合的方法最常用。别名最简单。内嵌主要是go语言特殊的地方用来节省代码。</p></li><li><p>结构体内嵌扩展属于go的一个语法糖。主要体现在可以省去被内嵌结构体的变量名，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span>&#123;</span><br><span class="line">    *oldStruct    <span class="comment">//只有类型名，省去变量名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        内嵌类似其余语言的继承，影子函数类似重载。但是本质上不是继承，实际上两个结构体没有本质的联系。比如go无法实现其他函数的继承的做法，如将子类指针想要赋值给基类指针，利用基类指针调用重载函数。这一目的通过接口实现。</p></li></ul>]]></content>
    
    <summary type="html">
    
      简单语法
    
    </summary>
    
    
      <category term="go" scheme="https://lilac18.cn/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>WR20-3-28</title>
    <link href="https://lilac18.cn/2020/03/28/WR20-3-28/"/>
    <id>https://lilac18.cn/2020/03/28/WR20-3-28/</id>
    <published>2020-03-28T07:51:49.000Z</published>
    <updated>2020-03-28T08:32:41.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本周工作"><a href="#本周工作" class="headerlink" title="本周工作"></a>本周工作</h3><p>1，合约部署的报错属于BUG，web3和最新的Solidity会出现Bug。Github报错大多数都是不同版本，没有有效的解决办法。当前web3仍然问题很多，等待Web3更新。最终只能切换0.4版本的Solidity，没有出现报错。但是0.4版本的Solidity很旧问题很多，只能作为学习。</p><p>2，GANACHE未找到可以真正本地存储的方法。现存的本地存储上次状态都是存储到内存或者存储为临时文件，并没有实际的区块保存，因此只能像在线Remix网络一样作为测试合约可用性的的测试网络。</p><p>3，分配单机多节点测试以太坊网络。区块同步比预想要效率低下。</p><p>4，从头仔细学习Solidity。加深对一些概念的理解</p><p>5，当前的学习和Dapp开发有较大差异，寻找继续的方向。</p><p>6，做读取大文件测试。学习python读取大文件CSV文件。pandas和dask.dataframe相关学习。</p><h3 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h3><h3 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h3><p>1，寻找并学习DAPP开发实例，目的是加深对合约开发的理解。</p><p>2，Nodejs寻找合适的框架进行实践，提高解决问题能力。</p><p>3，专注于Solidity的学习。</p><p>4，公链开发和私链开发区别较大，进行了解。</p>]]></content>
    
    <summary type="html">
    
      周报 20-3-28
    
    </summary>
    
    
      <category term="week report" scheme="https://lilac18.cn/categories/week-report/"/>
    
    
  </entry>
  
  <entry>
    <title>WR20-3-21</title>
    <link href="https://lilac18.cn/2020/03/21/WR20-3-21/"/>
    <id>https://lilac18.cn/2020/03/21/WR20-3-21/</id>
    <published>2020-03-21T08:00:50.000Z</published>
    <updated>2020-03-21T08:53:47.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本周工作"><a href="#本周工作" class="headerlink" title="本周工作"></a>本周工作</h3><p>1，web3和Truffle分别测试部署简单合约到GANACHE没出现问题。但是部署到实际的Geth发现问题。更改web3版本和部署代码及Geth版本，问题未得到解决，资料较少，打算重新部署Geth进行尝试。</p><p>2，GANACHE要作为测试链优点是少去了的挖矿打包的过程，缺点是是模拟的每次重启会刷新。</p><p>3，web3 1.0学习，Nodejs学习。</p><h3 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h3><h4 id="FastKitten-Practical-Smart-Contracts-on-Bitcoin-USENIX-2019"><a href="#FastKitten-Practical-Smart-Contracts-on-Bitcoin-USENIX-2019" class="headerlink" title="FastKitten: Practical Smart Contracts on Bitcoin (USENIX 2019)"></a>FastKitten: Practical Smart Contracts on Bitcoin (USENIX 2019)</h4><p><strong>问题描述：</strong>区块链上的智能合约本质上是区块链上的代码，能够进行逻辑运算。比如可以使用智能合约实现上图所示的扑克牌游戏，三个玩家分别向智能合约输入自己的牌，然后智能合约进行逻辑运算，确定赢家，输出结果。但是当前区块链最成功的应用之一比特币不支持智能合约。是否可以让比特币网络支持智能合约？</p><p><strong>论文贡献</strong>本论文针对比特币网络提出了一个能够在链外执行（off-chain execution）且能执行多个轮回（multi-round）的高效的智能合约协议FastKitten，它具有强的隐私和安全性以及速度快的特点。</p><p><strong>主体方案</strong></p><p><em>1 可执行环境</em></p><p>​        一个理想的TEE可以理解为一个沙盒，任何人都不能改变和窥探里面的执行逻辑和状态信息。一个TEE能够保证其中的逻辑代码被正确执行，维护其中的隐私状态，并且能够提供TEE中的程序被正确设置的证明。</p><p><em>2 FastKitten协议</em></p><p>​        该协议可以分为四个主体，分别为TEE，Operator，Parties和区块链。可以把TEE理解为一台特殊的服务器，Operator便是这台服务器的拥有者；Parties是活动的参与者，比如打扑克牌的三个人；区块链就是比特币中的区块链。FastKitten协议分为三个阶段。 </p><p>（1）(1)  Setup阶段</p><p>​        Operator提交惩罚押金给智能合约。把Operator的惩罚押金转给每一个parties，但是它time-lock的，只有到了timeout的时间之后，该交易的输出金额才能被parties花费掉。对于各个Party，她们通过验证Operator发过来的数据，知道Operator已经提交了押金，以及TEE已经设置好了。于是她们向智能合约提交惩罚押金。</p><p>（2）Round阶段</p><p>1）各个parties通过Operator向TEE发送智能合约的输入数据，</p><p>2）TEE计算得到结果，</p><p>3）通过Operator向各个parties返回TEE的计算结果。</p><p>​        这个过程可以根据需要重复多次。所有在网络中传输的数据都通过程TLS来加密，因此Operator无法知道parties的输入内容和TEE的计算结果。round阶段不用访问区块链的。</p><p>（3）finalize阶段</p><p>​        上一个阶段智能合约执行了其中的代码逻辑，得到了扑克牌游戏的赢家，需要发布结果。Operator通过TEE的最终计算结果的输出向区块链发起一个交易，用于向Operator和各个parties退还押金以及向赢家发送相关报酬等。这一步的操作写到区块链中，防止篡改和欺骗。</p><p><strong>作恶</strong>  </p><p>​    可以归结为两种，一种是篡改数据，第二种是丢弃数据或者故意停止工作。前者可以通过数字签名来解决。论文主要讲解后者。</p><p>（1）   情况1，operator作恶</p><p>如果Operator故意丢弃数据或者故意停止服务，那么其之前所提交的押金在timeout之后被各个parties消费掉，以此来惩罚operator。</p><p>（2）   情况2，party作恶</p><p>​        比如Alice故意停止工作，没有给Operator发送TEE所需要的input数据。这时候TEE没有收到Alice的input数据，但是TEE不确定是Operator丢弃了该数据还是Alice没有发送。Operator为了证明自己的清白，它向区块链发起一个challenge交易，该交易的输入是Operator自己的一些未花费的钱，输出是Alice的地址，并且有一个数据域Data，里面存储了在当前round中TEE计算结果的输出值 。如果Alice没有作恶，只是她发给Operator的input数据在网络传输途中丢失了。这时候，Alice需要证明自己的清白，需要回应Operator所发起的challenge交易。Alice需要时时检查有没有发给自己的challenge交易，如果有，需要向区块链发起一个交易，作为对应challenge交易的回应。该response交易的输入是Operator发给Alice的钱，输出是Operator的地址，目的是把这个钱返还给Operator，并且其数据域Data是发送给TEE的input数据。这样，Operator检查到Alice的回应之后，就能够从区块链中拿到这个input数据，然后转发给TEE，TEE正常执行。如果在Operator发起 过了一定的时间之后Alice还是没有反应，那么TEE中的智能合约就能够断定Alice作恶，因此没收Alice的押金，结束协议。</p><p>​        没收Alice的押金：通过向区块链发起一个交易,其输出包含Operator的地址和除了Alice的其它parties的地址。</p><h3 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h3><p>1，Solidity学习不够深入，需强化理解本质。</p><p>2，解决当前部署遇到的问题。</p><p>3，GANACHE的本地存储。</p>]]></content>
    
    <summary type="html">
    
      周报 20-3-21
    
    </summary>
    
    
      <category term="week report" scheme="https://lilac18.cn/categories/week-report/"/>
    
    
  </entry>
  
  <entry>
    <title>WR20-3-14</title>
    <link href="https://lilac18.cn/2020/03/14/WR20-3-14/"/>
    <id>https://lilac18.cn/2020/03/14/WR20-3-14/</id>
    <published>2020-03-14T02:19:12.000Z</published>
    <updated>2020-03-14T03:01:58.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本周工作"><a href="#本周工作" class="headerlink" title="本周工作"></a>本周工作</h3><p>1，web3新版官方文档学习。发现web3版本冲突的问题，之前旧版本的0.2.0。新版本1.0.0改动较大。涉及到异步和合约编译部署及区块链交互的地方更改较多，网上教程杂乱，选择官方文档选择性学习。</p><p>2，学习solidity官方文档的常见模式。之前solidity学习基本语法和实例略过了一些语言特性。关于solidity的提款模式和限制模式进一步学习。整体感觉solidity虽然可以在EVM编程，但实际限制很多，大多数人利用solidity开发dapp。</p><p>3，学习Truffle的使用方法及应用流程。可以极大程度简化合约编译和部署。但是更多倾向于类似于前端的Dapp开发。后续根据需求决定采用与否。</p><p>4，之前的区块链以node作为服务端，通过写入写出的智能合约与以太坊交互。好处是可以解耦合。现在可以直接利用web3与区块链写入写出。后续考虑采取哪种方式。</p><p>5，发现web3更偏向于nodejs。补充学习，和js更多的是语法上相同，但实际的用法差异较大。</p><h3 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h3><p>1，继续学习web3 1.0官方文档</p><p>2，寻找更加便捷好用的solidity开发工具</p><p>3，了解GANACHE，当前部署和测试直接在私有链进行，打算利用GANACHE作为测试私有链，了解并测试考虑可用性</p><p>4，针对时间完善Truffle学习，了解Dapp。</p>]]></content>
    
    <summary type="html">
    
      周报 20-3-14
    
    </summary>
    
    
      <category term="week report" scheme="https://lilac18.cn/categories/week-report/"/>
    
    
  </entry>
  
  <entry>
    <title>WR20-3-7</title>
    <link href="https://lilac18.cn/2020/03/07/WR20-3-7/"/>
    <id>https://lilac18.cn/2020/03/07/WR20-3-7/</id>
    <published>2020-03-07T07:38:04.000Z</published>
    <updated>2020-03-07T09:05:56.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="科研工作"><a href="#科研工作" class="headerlink" title="科研工作"></a>科研工作</h3><span class="label success">1,web3接口学习</span><p>remix比本地solc编译器简单易用，但是利用remix开发会比较繁琐。利用web3对合约进行编译、部署、测试。寻求更为实用的开发框架和环境。</p><span class="label success">2,solidity学习</span><p>结合实例进一步学习。</p><span class="label success">3,思考学姐方案需求，进行简单gas花费测试</span><p>对存储简单状态变量进行测试，影响gas的诸多因素没考虑清楚，测试结果只能作为参考。</p><span class="label success">3,阅读论文</span><p>《The mathematics of bitcoin》2020未发表。</p><p>本文是一篇偏数学的文章。在数学的角度对比特币进行分析。引入了很多经济学的概念和形式化定义。鞅理论、马尔科夫链、戴克词等。1，挖矿。挖每个区块的时间服从指数分布，挖n个区块时间服从n重卷积指数分布。区块数和平均出块时间服从伽马分布。验证区块时间服从泊松分布。2，双花问题。整理前人结论，数学角度证明攻击成功率随着确认区块增加而减少。3，挖矿收益。挖矿策略的收益参考伽马分布值。证明了在难度值不变的情况下，最佳挖矿策略是尽快发布。4，难度值不可调控时最好的挖矿策略是尽快发布。文章之后讲的自私挖矿策略及戴克词等没太看懂。本文主要启发人们比特币中的数学问题。</p><h3 id="下周科研计划"><a href="#下周科研计划" class="headerlink" title="下周科研计划"></a>下周科研计划</h3><span class="label primary">了解Truffle框架并考虑实用性</span><br><span class="label primary">完善solidity学习，继续web3学习</span><br><span class="label primary">结合实例实践智能合约场景和web3</span>]]></content>
    
    <summary type="html">
    
      周报20.3.7
    
    </summary>
    
    
      <category term="week report" scheme="https://lilac18.cn/categories/week-report/"/>
    
    
  </entry>
  
  <entry>
    <title>image-test</title>
    <link href="https://lilac18.cn/2020/02/24/image-test/"/>
    <id>https://lilac18.cn/2020/02/24/image-test/</id>
    <published>2020-02-24T08:53:53.000Z</published>
    <updated>2020-02-24T08:55:35.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lilac-image-1301357031.cos.ap-chengdu.myqcloud.com/undefined/20200224165526-395579.jpeg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      test image
    
    </summary>
    
    
      <category term="hexo" scheme="https://lilac18.cn/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>WR20-2-22</title>
    <link href="https://lilac18.cn/2020/02/24/WR20-2-22/"/>
    <id>https://lilac18.cn/2020/02/24/WR20-2-22/</id>
    <published>2020-02-24T07:43:00.000Z</published>
    <updated>2020-02-24T09:05:57.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本周科研工作"><a href="#本周科研工作" class="headerlink" title="本周科研工作"></a>本周科研工作</h3><span class="label success">1,实现了GBF原型</span><p>碰到的问题，秘密共享使用的是异或，存储非整型数据时需要想办法解决。初步采取hash投映为整型。由于证书的数据结构未知，且存储到布隆过滤器的表示方式未知，后续问题后续结合实际解决。</p><span class="label success">2,完成了以太坊部署</span><span class="label success">3,明白了Remix运行原理</span><span class="label success">4,阅读论文</span><p>《Xor Filters: Faster and Smaller Than Bloom and Cuckoo Filters》2019未发表。</p><p>本文构造了一个比布隆过滤器更快的异或过滤器。主要思路是：将集合S中所有元素x的指纹f(x)（由随机哈希函数生成）存放到数组B中。有三个哈希函数h0,h1,h2。三个哈希函数值域平分|B|（|B|&gt;|S|）。试图找到B[h0(x)] xor B[h1(x)] xor B[h2(x)]=f(x)。构造过程主要是利用一个临时数组H，选定一组h0,h1,h2,在H[h0(x)]、H[h1(x)]、H[h2(x)]存放x。集合S所有元素完成存放之后，找H中存放单个元素的位置，记录到一个队列里。遍历队列，将位置和元素存放到栈里。如果栈大小与S相同，进行存放。不成功重新选取哈希函数组。概括来说与元素x相关联的位置i为h0(x),h1(x),h2(x)之一。重新构造B，在i的位置存放f(x) xor B[h0(x)] xor B[h1(x)] xor B[h2(x)]。但是我感觉文中的几个算法有问题，逻辑想不通。尤其最后存放这一步很奇怪，我思考觉得有一定问题。</p><h3 id="下周科研计划"><a href="#下周科研计划" class="headerlink" title="下周科研计划"></a>下周科研计划</h3><span class="label primary">完成线下智能合约环境搭建</span><span class="label primary">完善JS学习，继续Solidity学习</span><span class="label primary">争取时间调研过滤器的应用场景</span>]]></content>
    
    <summary type="html">
    
      周报20.2.22
    
    </summary>
    
    
      <category term="week report" scheme="https://lilac18.cn/categories/week-report/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello,Hexo</title>
    <link href="https://lilac18.cn/2020/02/18/Hello/"/>
    <id>https://lilac18.cn/2020/02/18/Hello/</id>
    <published>2020-02-18T06:30:59.000Z</published>
    <updated>2020-02-24T09:05:16.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是我第一次使用博客，也是第一次使用markdown"><a href="#这是我第一次使用博客，也是第一次使用markdown" class="headerlink" title="这是我第一次使用博客，也是第一次使用markdown"></a>这是我第一次使用博客，也是第一次使用markdown</h3>]]></content>
    
    <summary type="html">
    
      first blog
    
    </summary>
    
    
      <category term="博客入门" scheme="https://lilac18.cn/categories/%E5%8D%9A%E5%AE%A2%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
</feed>
